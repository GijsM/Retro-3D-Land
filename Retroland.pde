/*
Retro 3D Land at Night by Gijs Mulder
 This code randomly generates a 3D landscape, a moon and stars and displays it in a 90s 3D style.
 */

//Values which determine the looks of the landscape
int columns = 600;
int rows = 300;
int framesize = 1000;
int resolution = 10;
int noiseResolution = 60;

void setup() {
  //Unfortunately size() does not take variables, but the values should be equal to framesize   
  size(1000, 1000, P3D);

  //Handpicked seed which looks good
  noiseSeed(9);
  noLoop();
}

void draw() {
  background(0);
  //translate to the middle and a bit up for the best view of the landscape
  translate(framesize/2, framesize/1.7, -framesize/2);

  //Style and colors of the landscape
  strokeWeight(1);
  stroke(#54D7ED);
  fill(0);

  //Code for creating the moon
  pushMatrix();
  //translate to the middle-back of the frame
  translate(0, -framesize*2, -columns/2*resolution);
  sphereDetail(15);
  sphere(framesize/2);
  popMatrix();

  //Code for creating the stars
  for (int i =0; i<100; i++) {
    pushMatrix();
    //translate to a random location at the back of the frame
    translate(random(framesize*6)-framesize*3, random(framesize*4)-framesize*3, -columns/2*resolution);
    sphereDetail(1);
    sphere(framesize/50);
    popMatrix();
  }

  //Rotate the angle of the view to create a 90 degree viewing angle of the scene 
  rotateX(PI/2);

  //Code for generating the terain
  for (int y = -columns/2; y < columns/2; y++) {
    //One strip of squares for each column
    beginShape(QUAD_STRIP);
    for (int x = -rows/2; x < rows/2; x++) {
      //Create a vertex at every x and y coordinate with a height generated by getHeight to create the landscape
      vertex(x*resolution, y*resolution, getHeight(x, y));
      //QUAD_STRIPs are generated using a saw-like pattern which is made by creating one extra vertex going one down the y coordinate each time
      vertex(x*resolution, (y+1)*resolution, getHeight(x, y+1));
    }
    endShape();
  }
}

int getHeight(int x, int y) {
  //the noise method changes very rapidly with integer x and y values, for a nicer landscape we devide x and y by a large number for smaller increments.
  //the noise method is also symetric around 0. The x and y values go from negative to positive, this will generate a mirrored landscape.
  //to avoid this we add a positive number to x and y so the outcome is always positive
  float xNoise = (float) (x + rows)/noiseResolution;
  float yNoise = (float) (y + columns)/noiseResolution;

  //Raising a number from 0-1 to the power 3 causes it to shrink even more if its closer to 0 and stay relatively unchanged if its closer to 1.
  //This generates smooth valleys and sharp mountain peaks
  float noise = pow(noise(xNoise, yNoise), 3)*30;
  
  //noise gets multiplied by a precalculated value for optimalization, otherwise the same constants will have to be calculated again and again for each row.
  //more info about the constants below where they get calculated.
  int heightresult = (int) (xParabola[x+rows/2]*noise)-200;

  return heightresult;
}

float[] xParabola = new float[rows];
{
  for (int x = -rows/2; x < rows/2; x++) {
    //multiplying by the absolute value of x to the power of 2 (x is also devided by 10 to get a larger parabola) makes sure that the middle (where x is around 0) is always relatively flat so mountains don't obstruct the view. The result is a parabola valley
    //to avoid a line in the middle a small value (15) is added so its never equal to 0. 200 is subtracted in the end so the view is never below the surface of the terrain
    xParabola[x+rows/2] = (pow((float)abs(x)/10, 2)+15);
  }
}